import{_ as e,C as n,c as t,o as l,j as a,G as p,ai as h,a as r}from"./chunks/framework.6CbiclxB.js";const b=JSON.parse('{"title":"支付系统核心集成与异常复盘指南","description":"","frontmatter":{"title":"支付系统核心集成与异常复盘指南"},"headers":[],"relativePath":"system-design/支付系统核心集成与异常复盘指南.md","filePath":"system-design/支付系统核心集成与异常复盘指南.md","lastUpdated":1768136749000}'),o={name:"system-design/支付系统核心集成与异常复盘指南.md"};function d(k,s,c,g,E,u){const i=n("ArticleMetadata");return l(),t("div",null,[s[0]||(s[0]=a("h1",{id:"支付系统核心集成与异常复盘指南",tabindex:"-1"},[r("支付系统核心集成与异常复盘指南 "),a("a",{class:"header-anchor",href:"#支付系统核心集成与异常复盘指南","aria-label":'Permalink to "支付系统核心集成与异常复盘指南"'},"​")],-1)),p(i),s[1]||(s[1]=h(`<p>在支付集成项目中，由于涉及敏感证书管理、分布式事务一致性以及第三方 SDK 的深度耦合，极易在配置与部署阶段产生隐蔽 Bug。本篇文档聚焦微信支付集成中的架构设计、资源管理及典型报错修复。</p><h3 id="_1-核心架构-退款处理流程与幂等保障" tabindex="-1">1. 核心架构：退款处理流程与幂等保障 <a class="header-anchor" href="#_1-核心架构-退款处理流程与幂等保障" aria-label="Permalink to &quot;1. 核心架构：退款处理流程与幂等保障&quot;">​</a></h3><p>退款流程不仅包含同步请求，更依赖异步通知以确保最终一致性。</p><ul><li><strong>流程拆解</strong>： <ol><li><strong>商户发起请求</strong>：调用微信退款接口，创建退款单。</li><li><strong>微信处理</strong>：进入 <code>REFUND_PROCESSING</code> 状态。</li><li><strong>异步通知</strong>：微信回调商户接口（如 <code>/refunds/notify</code>）。</li></ol></li><li><strong>并发保护（分布式锁）</strong>： 在回调处理逻辑中，必须使用分布式锁（如 Redisson）或本地锁（<code>lock.tryLock()</code>）来防止<strong>重复回调</strong>或<strong>与查询轮询任务冲突</strong>导致的状态机异常。<div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tryLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1. 检查订单是否处于处理中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String orderStatus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orderInfoService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrderStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(orderNo);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OrderStatus.REFUND_PROCESSING.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(orderStatus)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 2. 状态机转换：处理中 -&gt; 成功</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        orderInfoService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateStatusByOrderNo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(orderNo, OrderStatus.REFUND_SUCCESS);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        refundsInfoService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateRefund</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(plainText);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 严格释放锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><hr><h3 id="_2-技术难点-httpclient-资源管理与证书注入" tabindex="-1">2. 技术难点：HttpClient 资源管理与证书注入 <a class="header-anchor" href="#_2-技术难点-httpclient-资源管理与证书注入" aria-label="Permalink to &quot;2. 技术难点：HttpClient 资源管理与证书注入&quot;">​</a></h3><h4 id="_2-1-closeablehttpclient-机制" tabindex="-1">2.1 CloseableHttpClient 机制 <a class="header-anchor" href="#_2-1-closeablehttpclient-机制" aria-label="Permalink to &quot;2.1 CloseableHttpClient 机制&quot;">​</a></h4><p><code>CloseableHttpClient</code> 实现了 <code>Closeable</code> 接口。在支付场景下，它不仅是发送请求的工具，还持有 SSL 上下文和连接池。</p><ul><li><strong>重点关注</strong>：必须确保在请求结束后调用 <code>close()</code>，或利用 <code>try-with-resources</code> 自动释放。内部通过成员变量 <code>closeables</code> 链式关闭所有关联资源。</li></ul><h4 id="_2-2-微信-sdk-客户端配置-bean-管理" tabindex="-1">2.2 微信 SDK 客户端配置 (Bean 管理) <a class="header-anchor" href="#_2-2-微信-sdk-客户端配置-bean-管理" aria-label="Permalink to &quot;2.2 微信 SDK 客户端配置 (Bean 管理)&quot;">​</a></h4><p>通过 <code>WechatPayHttpClientBuilder</code> 构建的客户端会自动处理<strong>签名与验签</strong>，以及<strong>证书的定期更新</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Bean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;wxPayClient&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CloseableHttpClient </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getWxPayClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ScheduledUpdateCertificatesVerifier verifier){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PrivateKey privateKey </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getPrivateKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(privateKeyPath); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注入商户私钥</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WechatPayHttpClientBuilder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withMerchant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mchId, mchSerialNo, privateKey) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置商户信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">withValidator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WechatPay2Validator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(verifier)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开启验签</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="_3-典型错误复盘-bug-watch" tabindex="-1">3. 典型错误复盘 (Bug Watch) <a class="header-anchor" href="#_3-典型错误复盘-bug-watch" aria-label="Permalink to &quot;3. 典型错误复盘 (Bug Watch)&quot;">​</a></h3><h4 id="_3-1-druid-加密与微信-sdk-冲突" tabindex="-1">3.1 Druid 加密与微信 SDK 冲突 <a class="header-anchor" href="#_3-1-druid-加密与微信-sdk-冲突" aria-label="Permalink to &quot;3.1 Druid 加密与微信 SDK 冲突&quot;">​</a></h4><p><strong>错误信息</strong>：<code>java.lang.IllegalArgumentException: Failed to decrypt.</code></p><ul><li><strong>现象</strong>：在 Druid 数据源初始化时报错。</li><li><strong>根本原因</strong>：Druid 开启了配置文件加密功能（<code>ConfigFilter</code>），而在解析微信支付相关密钥或数据库密码时，解密逻辑冲突或公钥配置错误。</li><li><strong>避坑指南</strong>：若未使用 Druid 密码加密功能，请移除配置文件中的 <code>filters: config</code> 属性。</li></ul><h4 id="_3-2-证书文件路径与编译过滤" tabindex="-1">3.2 证书文件路径与编译过滤 <a class="header-anchor" href="#_3-2-证书文件路径与编译过滤" aria-label="Permalink to &quot;3.2 证书文件路径与编译过滤&quot;">​</a></h4><p><strong>现象</strong>：<code>getPrivateKey</code> 报错 <code>FileNotFoundException</code>，但文件确实在 <code>resources</code> 目录下。</p><ul><li><p><strong>根本原因</strong>：Maven 编译时可能会对 <code>resources</code> 下的文件进行 <code>filter</code> 处理（变量替换），破坏了 <code>pem</code> 或 <code>p12</code> 证书的二进制结构。</p></li><li><p><strong>修复方案</strong>：在 <code>pom.xml</code> 中排除证书文件的过滤：</p><p>XML</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;plugin&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;configuration&gt;</span></span>
<span class="line"><span>        &lt;nonFilteredFileExtensions&gt;</span></span>
<span class="line"><span>            &lt;extension&gt;p12&lt;/extension&gt;</span></span>
<span class="line"><span>            &lt;extension&gt;pem&lt;/extension&gt;</span></span>
<span class="line"><span>        &lt;/nonFilteredFileExtensions&gt;</span></span>
<span class="line"><span>    &lt;/configuration&gt;</span></span>
<span class="line"><span>&lt;/plugin&gt;</span></span></code></pre></div></li></ul><h4 id="_3-3-数值处理与分转元" tabindex="-1">3.3 数值处理与分转元 <a class="header-anchor" href="#_3-3-数值处理与分转元" aria-label="Permalink to &quot;3.3 数值处理与分转元&quot;">​</a></h4><p>微信支付金额以“分”为单位，展示层需转换为“元”。</p><ul><li><p><strong>风险点</strong>：直接使用 <code>Double</code> 会导致精度丢失，必须使用 <code>BigDecimal</code>。</p><p>Java</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 分 -&gt; 元</span></span>
<span class="line"><span>BigDecimal payTotalByYuan = BigDecimal.valueOf(payerTotal)</span></span>
<span class="line"><span>        .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);</span></span></code></pre></div></li></ul><hr><h3 id="_4-依赖与编译环境建议" tabindex="-1">4. 依赖与编译环境建议 <a class="header-anchor" href="#_4-依赖与编译环境建议" aria-label="Permalink to &quot;4. 依赖与编译环境建议&quot;">​</a></h3><ul><li><strong>Druid 适配</strong>：确保引入 <code>druid-spring-boot-starter:1.2.20</code> 以兼容较新的 Spring Boot 版本。</li><li><strong>SQL 不支持异常</strong>：若遇到 <code>SQLFeatureNotSupportedException</code>，检查数据库驱动版本（如 MySQL 8.x 与 5.x 驱动差异）或分页插件是否配置正确。</li><li><strong>Node/前端镜像</strong>：删除 <code>package-lock.json</code> 后重新 <code>npm install</code> 通常是安全的，前提是 <code>package.json</code> 中的版本范围（如 <code>^</code>）没有引入不兼容的主版本更新。</li></ul><hr><p>在 12306 等高并发场景下，支付模块不仅涉及第三方 SDK（如支付宝）的对接，更需要通过 <strong>TCC (Try-Confirm-Cancel)</strong>、<strong>模板模式</strong>以及 <strong>RocketMQ</strong> 确保订单、库存与支付状态的强一致性。</p><h3 id="_1-支付与退款-基于模板模式的抽象" tabindex="-1">1. 支付与退款：基于模板模式的抽象 <a class="header-anchor" href="#_1-支付与退款-基于模板模式的抽象" aria-label="Permalink to &quot;1. 支付与退款：基于模板模式的抽象&quot;">​</a></h3><p>为了兼容多种支付渠道（支付宝、微信），系统对支付与退款流程进行了高度抽象。</p><h4 id="_1-1-抽象类设计" tabindex="-1">1.1 抽象类设计 <a class="header-anchor" href="#_1-1-抽象类设计" aria-label="Permalink to &quot;1.1 抽象类设计&quot;">​</a></h4><ul><li><strong><code>AbstractPayRequest</code></strong>: 统一定义支付请求字段，利用 <code>@JsonAlias</code> 实现 JSON 字段多名称对齐（如兼容 <code>trade_status</code> 与 <code>tradeStatus</code>）。</li><li><strong>处理类矩阵</strong>: <ul><li><code>AbstractPayHandler.java</code>: 支付逻辑抽象。</li><li><code>AbstractPayCallbackHandler.java</code>: 处理第三方回调。</li><li><code>AbstractRefundHandler.java</code>: 抽象退款逻辑。</li></ul></li></ul><h4 id="_1-2-支付与退款流程图" tabindex="-1">1.2 支付与退款流程图 <a class="header-anchor" href="#_1-2-支付与退款流程图" aria-label="Permalink to &quot;1.2 支付与退款流程图&quot;">​</a></h4><p>系统严格按照第三方 SDK 要求构建 Model、Request，并处理响应 Code。</p><hr><h3 id="_2-分布式事务-tcc-预处理机制" tabindex="-1">2. 分布式事务：TCC 预处理机制 <a class="header-anchor" href="#_2-分布式事务-tcc-预处理机制" aria-label="Permalink to &quot;2. 分布式事务：TCC 预处理机制&quot;">​</a></h3><p>支付过程中常伴随积分扣减、优惠券核销等，必须通过 TCC 模式处理。</p><ul><li><strong>Try (预留机制)</strong>： <ul><li>在 Redis 中存储未支付临时信息（Key: <code>ORDER_PAY_RESULT_INFO</code>）。</li><li>冻结用户积分或优惠券，状态设为“扣减中”。</li></ul></li><li><strong>Confirm (确认)</strong>： <ul><li>收到支付成功回调，正式扣减资源，删除 Redis 临时缓存。</li></ul></li><li><strong>Cancel (取消)</strong>： <ul><li>支付超时或用户取消，回滚冻结的资源，恢复库存。</li></ul></li></ul><hr><h3 id="_3-微服务核心组件集成" tabindex="-1">3. 微服务核心组件集成 <a class="header-anchor" href="#_3-微服务核心组件集成" aria-label="Permalink to &quot;3. 微服务核心组件集成&quot;">​</a></h3><h4 id="_3-1-远程调用-feign-优化" tabindex="-1">3.1 远程调用 Feign 优化 <a class="header-anchor" href="#_3-1-远程调用-feign-优化" aria-label="Permalink to &quot;3.1 远程调用 Feign 优化&quot;">​</a></h4><p>通过 <code>ConfigurableEnvironment</code> 动态设置活动配置文件（Profiles），并结合 Feign 动态 URL 适配不同环境。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FeignClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;index12306-order-service&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;\${aggregation.remote-url:}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OrderFeignClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GetMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/orders/{orderId}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrderById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PathVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orderId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">orderId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-2-消息驱动-rocketmq" tabindex="-1">3.2 消息驱动 (RocketMQ) <a class="header-anchor" href="#_3-2-消息驱动-rocketmq" aria-label="Permalink to &quot;3.2 消息驱动 (RocketMQ)&quot;">​</a></h4><p>利用 <strong><code>MessageWrapper</code></strong> 装饰消息，确保幂等性。通过 <code>selectorExpression</code>（标签过滤）精确处理回调。</p><ul><li><strong>CG (消费者组)</strong>: <code>PAY_RESULT_CALLBACK_ORDER_CG_KEY</code>。</li><li><strong>Tag (标签)</strong>: <code>PAY_RESULT_CALLBACK_TAG_KEY</code>。</li></ul><hr><h3 id="_4-数据安全与异常处理" tabindex="-1">4. 数据安全与异常处理 <a class="header-anchor" href="#_4-数据安全与异常处理" aria-label="Permalink to &quot;4. 数据安全与异常处理&quot;">​</a></h3><h4 id="_4-1-自定义序列化-脱敏处理" tabindex="-1">4.1 自定义序列化（脱敏处理） <a class="header-anchor" href="#_4-1-自定义序列化-脱敏处理" aria-label="Permalink to &quot;4.1 自定义序列化（脱敏处理）&quot;">​</a></h4><p>对于证件号（idCard）等敏感信息，在返回前端前通过 <code>IdCardDesensitizationSerializer</code> 进行脱敏。</p><p>Java</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@JsonSerialize(using = IdCardDesensitizationSerializer.class)</span></span>
<span class="line"><span>private String idCard; // 输出示例：1101***********123</span></span></code></pre></div><h4 id="_4-2-支付宝异常体系" tabindex="-1">4.2 支付宝异常体系 <a class="header-anchor" href="#_4-2-支付宝异常体系" aria-label="Permalink to &quot;4.2 支付宝异常体系&quot;">​</a></h4><p>自定义 <code>AlipayApiException</code>，封装 <code>errCode</code> 与 <code>errMsg</code>，方便 AOP 统一捕获并返回友好的 <code>ServiceException</code>。</p><hr><h3 id="_5-分布式-id-生成-基因法与自增" tabindex="-1">5. 分布式 ID 生成：基因法与自增 <a class="header-anchor" href="#_5-分布式-id-生成-基因法与自增" aria-label="Permalink to &quot;5. 分布式 ID 生成：基因法与自增&quot;">​</a></h3><p>在多服务/分库分表环境下，生成唯一订单 ID 时，将用户标识位（基因）注入 ID 中。</p><ul><li><strong>原理</strong>：<code>ID = Timestamp + MachineID + (UserId % 32)</code>。</li><li><strong>作用</strong>：确保同一用户的订单落在同一分片，提升查询性能。</li></ul><p>Markdown</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Redis Key 定义</span></span>
<span class="line"><span>public final class RedisKeyConstant {</span></span>
<span class="line"><span>    /** 订单结果缓存标识 */</span></span>
<span class="line"><span>    public static final String ORDER_PAY_RESULT_INFO = &quot;index12306-pay-service:order_pay_result:&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,60))])}const _=e(o,[["render",d]]);export{b as __pageData,_ as default};
